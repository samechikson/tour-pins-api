const functions = require("firebase-functions");
const helpers = require("./helpers");
const request = require("request");
const VectorTile = require("@mapbox/vector-tile").VectorTile;
const Protobuf = require("pbf");
const zlib = require("zlib");

function extractFeaturesFromTile(data, zoom, x, y) {
  let buffer;
  // handle zipped buffers
  if (data[0] === 0x78 && data[1] === 0x9c) {
    console.log("inflated data");
    buffer = zlib.inflateSync(data);
  } else if (data[0] === 0x1f && data[1] === 0x8b) {
    console.log("gunzipped data");
    buffer = zlib.gunzipSync(data);
  } else {
    console.log("didn't modify data");
    buffer = data;
  }

  const tile = new VectorTile(new Protobuf(buffer));
  const layers = Object.keys(tile.layers);
  console.log(
    "ðŸš€ ~ file: mapbox-coordinates.ts ~ line 18 ~ readTile ~ layers",
    layers
  );

  const featureCollection = { type: "FeatureCollection", features: [] };

  const featuresToLookFor = ["green", "bunker", "fairway"];
  for (let layer of layers) {
    console.log("----- layer", layer, " -------");
    for (let i = 0; i < tile.layers[layer].length; i++) {
      console.log(tile.layers[layer].feature(i).properties);

      for (const feature of featuresToLookFor) {
        if (tile.layers[layer].feature(i).properties.type === feature) {
          featureCollection.features.push(
            tile.layers[layer].feature(i).toGeoJSON(x, y, zoom)
          );
        }
      }

      if (layer === "water") {
        const waterGeoJson = tile.layers[layer]
          .feature(i)
          .toGeoJSON(x, y, zoom);
        waterGeoJson.properties.type = "water";
        waterGeoJson.properties.id = Math.ceil(Math.random() * 1e8); // Dirty hack for random ID that looks like the ones generated by Mapbox. It just needs to be approximately unique
        featureCollection.features.push(waterGeoJson);
      }
    }
  }

  return featureCollection;
}

function lon2tile(lon, zoom) {
  return Math.floor(((lon + 180) / 360) * Math.pow(2, zoom));
}

function lat2tile(lat, zoom) {
  return Math.floor(
    ((1 -
      Math.log(
        Math.tan((lat * Math.PI) / 180) + 1 / Math.cos((lat * Math.PI) / 180)
      ) /
        Math.PI) /
      2) *
      Math.pow(2, zoom)
  );
}

function getMapboxTileUrlFromLatLong(zoom, x, y) {
  const baseUrl =
    process.env.MAPBOX_BASE_URL || functions.config().mapbox.base_url;
  const mapStyleId =
    process.env.MAPBOX_MAP_STYLE_ID || functions.config().mapbox.map_style_id;
  const access_token =
    process.env.MAPBOX_ACCESS_TOKEN || functions.config().mapbox.access_token;

  return `${baseUrl}${zoom}/${x}/${y}.mvt?style=${mapStyleId}&access_token=${access_token}`;
}

async function getGeoJson(zoom, lat, long) {
  const x = lon2tile(long, zoom);
  const y = lat2tile(lat, zoom);

  return new Promise((resolve, reject) => {
    request(
      {
        url: getMapboxTileUrlFromLatLong(zoom, x, y),
        gzip: true,
        encoding: null,
      },
      function (err, response, body) {
        if (err) {
          reject(err);
          return;
        }
        if (+response.statusCode > 299) {
          reject(body);
          return;
        }

        resolve(extractFeaturesFromTile(body, zoom, x, y));
      }
    );
  });
}

export const getMapboxVectorDataForCoordinates = functions.https.onCall(
  async (data, context) => {
    helpers.assertUID(context);
    const long = helpers.assert(data, "long");
    const lat = helpers.assert(data, "lat");
    const zoom = helpers.assert(data, "zoom");

    return await helpers.catchErrors(getGeoJson(zoom, lat, long));
  }
);
